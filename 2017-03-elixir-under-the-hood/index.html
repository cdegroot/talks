<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <!-- TODO move this stuff to an external CSS file at some point -->
    <style>
      body {
        font-family: 'Gill Sans';
        line-height: 1.5;
      }
      h1, h2, h3 {
        font-family: 'Gill Sans';
        font-weight: normal;
      }
      .remark-slide-content {
        font-size: 24pt;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Source Code Pro';
        font-size: 90%;
      }
      code {
        border-radius: 5px;
      }
      .remark-code-line {
        font-size: 65%;
      }
      .fn {
        font-size: 50%;
        vertical-align: super;
      }
      .footnote {
        font-size: 75%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Elixir Under the Hood

---
# Agenda

1. Introduction
2. What _are_ Erlang, BEAM, OTP?
3. OTP
4. Mix, releases

---
# Introduction

* Elixir is awesome-sauce on top of Erlang/BEAM/OTP
* Sometimes, though, you need to open up the hood
* Knowing the engine makes you a better developer

---
# Erlang

* The language originally developed by Joe Armstrong for Ericsson AB
* Mash-up of Prolog, Lisp, and other '80s cool things
* Language plus libs ("BIFs").fn[1]
* Immutable, pattern matching, functional

.footnote[.fn[1] https://rvirding.blogspot.ca/2009/10/what-are-bifs.html]

---
# BEAM

* The Erlang virtual machine
* Implements the Built-In-Functions
* Allows to talk to the ouside world (ports and NIFs)
* All the heavy lifting, basically

???

http://www.erlang-factory.com/upload/presentations/708/HitchhikersTouroftheBEAM.pdf

---
# OTP

* A set of conventions around Erlang+BEAM
* How to package stuff
* How to deploy/start stuff
* How to upgrade stuff

???
http://learnyousomeerlang.com/what-is-otpt

---
# OTP

You can write what you want without a single reference to OTP!

Use `send` / `receive` etcetera.

..but you shouldn't.

---
# Process mailboxes.fn[1]

* Unbounded FIFOs with filtering

```elixir
> send self(), :message_one
> send self(), :message_two
> receive do
>   :message_two -> IO.puts("Got message two")
> end
Got message two
>
```
What happened with message one?

.footnote[.fn[1] How to crash Erlang: http://prog21.dadgum.com/43.html]
???

Luckily, GenServer doesn't have a selective receive loop

---
# Everyday OTP

* Supervisor
* Application
* GenServer
* Agent
* Task

*OTP defines standard behavior*

---
# OTP Applications

* Deployable item under OTP
* Scope of reuse
* Group of supervised processes

Comparable with pretty much nothing else.

---
# Not so everyday OTP

* Releases
* Release handling

---
# Mix and OTP

It is very important to know what happens compile time
and what happens run time!

(Demo)

???

Demo steps:
- Open mix.exs
- Open config files and code.
- Run with various envs
- Release and run

---
# What happened there?

```elixir
  @world Application.get_env(:under_the_hood, :world)
```

A compile-time constant.

```elixir
  def hello_module do
    @world
  end
```

Therefore also a compile-time constant.

---
# What happene there?

```elixir
  def hello_config do
    Application.get_env(:under_the_hood, :world)
  end
```

Normal run-time stuff, so

```elixir
  def start(_, _) do
    Application.put_env(:under_the_hood, :world,
                        "go go go!")
    IO.puts("Hello_config: #{hello_config()}")
  end
```

Works as expected.

---
# Under the hood

```elixir
 def decompile(env) do
    beam = "_build/#{env}/lib/under_the_hood/ebin/Elixir.UnderTheHood.beam"
    |> to_charlist
    {:ok,{_,[{:abstract_code,{_,codez}}]}} =
      :beam_lib.chunks(beam, [:abstract_code])
    IO.puts(:erl_prettypr.format(
      :erl_syntax.form_list(codez)))
  end
```

(Demo)
???
    $ iex -S mix
    > UnderTheHood.decompile("dev")

---
# Under the hood

```elixir
$ iex -S mix
...
iex(1)> UnderTheHood.decompile("dev")
...
hello_config() ->
    'Elixir.Application':get_env(under_the_hood, world).

hello_module() -> <<"in dev">>.
...
```

---
# OTP Releases .fn[1]

```bash
$ MIX_ENV=prod mix release
Compiling 1 file (.ex)
==> Assembling release..
==> Building release under_the_hood:0.1.0 using environment prod
==> Including ERTS 8.2 from /Users/cees/.asdf/installs/erlang/19.2/lib/erlang/erts-8.2
==> Packaging release..
==> Release successfully built!
    You can run it in one of the following ways:
      Interactive: _build/prod/rel/under_the_hood/bin/under_the_hood console
      Foreground: _build/prod/rel/under_the_hood/bin/under_the_hood foreground
      Daemon: _build/prod/rel/under_the_hood/bin/under_the_hood start
```

.footnote[.fn[1](here with Distillery)]

---
# OTP Releases

```bash
$ _build/prod/rel/under_the_hood/bin/under_the_hood foreground
Hello_config: go go go!
Hello_module: production, dude!
```
..all good, but:
```bash
$ MIX_ENV=dev _build/prod/rel/under_the_hood/bin/under_the_hood foreground
Hello_config: go go go!
Hello_module: production, dude!
```
What happened to `MIX_ENV`??

---
# OTP Releases

*In a release, there's no Mix*

```erlang
$ cat _build/prod/rel/under_the_hood/releases/0.1.0/sys.config
[{sasl,[{errlog_type,error}]},
 {under_the_hood,[{world,<<"production, dude!">>}]}].
```
is all that's left of
```elixir
config :under_the_hood,
  world: "production, dude!"
```
---
# OTP Releases

*Do not use Mix for run-time configuration*

Alternatives:
* `Application.put_env` - but only if you know that this will be evaluated
before the application that needs it uses it;
* Distillery's dirty `sys.config` env var expansion hack.

---
# REPLACE_OS_VARS

*12FA for Elixir apps!*

```erlang
$ MIX_ENV=test mix release
...
$ cat _build/test/rel/under_the_hood/releases/0.1.0/sys.config
[{sasl,[{errlog_type,error}]},{under_the_hood,[{world,<<"${GREETING}">>}]}].
$ export REPLACE_OS_VARS=true GREETING=peoples
$ _build/test/rel/under_the_hood/bin/under_the_hood foreground
Hello before put: peoples
...
```
Awesome!

---
# REPLACE_OS_VARS

```erlang
$ export GREETING=build_time
$ MIX_ENV=test mix release
...
$ cat _build/test/rel/under_the_hood/releases/0.1.0/sys.config
[{sasl,[{errlog_type,error}]},{under_the_hood,[{world,<<"build_time">>}]}].
$ export REPLACE_OS_VARS=true GREETING=peoples
$ _build/test/rel/under_the_hood/bin/under_the_hood foreground
Hello before put: build_time
```
By now, you should grok this :-)

---
# Summary

* *Never* assign an `Application.get_env/2` to a module attribute
* *Do* use `REPLACE_OS_VARS` but be careful when building
* For your own application, a straight `System.get_env/1` may be preferable.

---
# Sidestep - Docker

* Use a release inside a Docker
* 12FA it with `REPLACE_OS_VARS`
* Shameless plug: `docker_distiller`.fn[1] does it all
  * Combines multiple releases in one container
  * Confusingly now allows MIX_ENV again ;-)

.footnote[.fn[1] https://github.com/PagerDuty/docker_distiller]

---
class: center, middle
That's all! Questions?

`@cdegroot`
    </textarea>
    <script src="../shared/js/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
  <!--
       Local Variables:
       mode: markdown
       End:
     -->
</html>
